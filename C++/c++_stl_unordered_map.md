
# âš¡ C++ STL :  unordered_map (í•´ì‹œ ê¸°ë°˜ í‚¤-ê°’ ì €ì¥)


---

## ğŸ“˜ unordered_map ì´ë€??

- unordered_mapì€ ìˆœì„œë¥¼ ê³ ë ¤í•˜ì§€ ì•Šê³  í‚¤-ê°’ ìŒì„ ì €ì¥í•˜ëŠ” í•´ì‹œ ê¸°ë°˜ ì—°ê´€ ì»¨í…Œì´ë„ˆ
- ë‚´ë¶€ì ìœ¼ë¡œ í•´ì‹œ í…Œì´ë¸”(hash table)ì„ ì‚¬ìš©í•˜ì—¬ í‰ê· ì ìœ¼ë¡œ O(1)ì˜ ë¹ ë¥¸ ê²€ìƒ‰ ì†ë„ë¥¼ ì œê³µ
- í‚¤ì˜ ì •ë ¬ì€ ë³´ì¥ë˜ì§€ ì•Šì§€ë§Œ, íƒìƒ‰, ì‚½ì…, ì‚­ì œê°€ ë§¤ìš° ë¹ ë¥¸ ê²ƒì´ ì¥ì 

---

## âœ…  ì˜ˆì œ

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string, int> um;

    um["apple"] = 100;
    um["banana"] = 200;
    um["cherry"] = 300;

    cout << "banana: " << um["banana"] << endl;

    for (auto& pair : um) {
        cout << pair.first << " : " << pair.second << endl;
    }

    if (um.find("apple") != um.end()) {
        cout << "apple ì¡´ì¬!" << endl;
    }

    um.erase("cherry");

    return 0;
}
```

---

## âœ… ì¶œë ¥ ê²°ê³¼

```
banana: 200
banana : 200
apple : 100
cherry : 300
apple ì¡´ì¬!
```

---

## âœ… ì£¼ìš” í•¨ìˆ˜

| í•¨ìˆ˜ | ì„¤ëª… |
|------|------|
| `um[key] = val` | ê°’ ì‚½ì… ë˜ëŠ” ìˆ˜ì • |
| `um.at(key)` | ì•ˆì „í•œ ì ‘ê·¼ (ì˜ˆì™¸ ë°œìƒ ê°€ëŠ¥) |
| `um.find(key)` | í‚¤ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸ |
| `um.erase(key)` | í•´ë‹¹ í‚¤ ì‚­ì œ |
| `um.size()` | ì „ì²´ ìš”ì†Œ ìˆ˜ |
| `um.empty()` | ë¹„ì–´ ìˆëŠ”ì§€ ì—¬ë¶€ |

---

## âœ… map vs unordered_map ì°¨ì´

|í•­ëª©|	map|	unordered_map|
|----|----|------|
|ë‚´ë¶€ êµ¬ì¡°|	Red-Black Tree (ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬)|	Hash Table (í•´ì‹œ í…Œì´ë¸”)|
|ì •ë ¬ ì—¬ë¶€|	í‚¤(key)ê°€ ìë™ ì •ë ¬ë¨ (ì˜¤ë¦„ì°¨ìˆœ)|	ì •ë ¬ë˜ì§€ ì•ŠìŒ (ì…ë ¥ ìˆœì„œ ë¬´ê´€)|
|íƒìƒ‰ ì†ë„ í‰ê· |	O(log n)|	O(1) (ì¶©ëŒ ì—†ì„ ë•Œ)|
|íƒìƒ‰ ì†ë„ ìµœì•…|	O(log n)	|O(n) (í•´ì‹œ ì¶©ëŒ ì‹¬í•  ê²½ìš°)|
|ì¤‘ë³µ í‚¤ í—ˆìš© ì—¬ë¶€|	âŒ ì¤‘ë³µ í‚¤ í—ˆìš© ì•ˆë¨|	âŒ ì¤‘ë³µ í‚¤ í—ˆìš© ì•ˆë¨|
|ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰|	ìƒëŒ€ì ìœ¼ë¡œ ì ìŒ|	í•´ì‹œ í…Œì´ë¸”ë¡œ ì¸í•´ ë” ë§ìŒ|
|ì‚¬ìš© ì¡°ê±´|	ì •ë ¬ëœ í‚¤ê°€ í•„ìš”í•  ë•Œ|	ë¹ ë¥¸ ì ‘ê·¼ì´ ì¤‘ìš”í•  ë•Œ|
|C++ ë²„ì „|	C++98ë¶€í„° ì§€ì›|	C++11ë¶€í„° ì§€ì›|

---
